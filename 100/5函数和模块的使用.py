"""
变成大师Martin Fowler曾经说过："代码有很多中坏味道，重复是最坏的一种"，要写出高质量的代码首先要解决的就是重复代码的问题
我们已将重复的代码封装到一个函数中，下次在需要此功能的时候直接调用就可以了。
"""
from random import randint
# from module1 import foo
from module3 import foo

import module3  # 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__

"""
定义函数
Python中使用def关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一直的。
在函数名后面的圆括号中可以防止传递给安徽拿出的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量
而程序执行完成后我们可以通过return关键字来返回一个值，这相当于数学上说的函数的因变量。

"""

"""
说明： Python的math模块中其实已经有一个名为factorial函数实现了阶乘运算，事实上求阶乘并不用自己定义函数。
下面的例子中，我们讲的函数在Python标准库已经实现过了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中并不建议做这种低级的重复劳动。
"""


def fac(num):
    """ 求阶乘 """
    result = 1
    for n in range(1, num + 1):
        result *= n
    return result


m = int(input("m = "))
n = int(input("n = "))
""" 当需要计算结成的时候不用在写循环秋阶乘二十直接调用已经定义好的函数 """
print(fac(m) // fac(n) // fac(m - n))

"""
函数的参数

函数是绝大数变成语言中都支持的一个代码的构建块，但是Python中的函数与其他变成语言中的函数还是有很多不同的地方
其中一个显著的区别就是使用Python对函数参数的处理。在Python中，函数的参数可以有哦默认值，也支持使用可变参数
所以Python并不需要像其他语言一样支持函数的重载，因为我们在定义 一个函数的时候可以让他有多种不同的使用方式。
"""


def roll_dice(n=2):
    """ 摇色子 """
    total = 0
    for _ in range(n):
        total += randint(1, 6)
    return total


def add(a=0, b=0, c=0):
    """ 三个数相加 """
    return a + b + c


""" 如果美哟指定参数那么使用默认值摇两颗色子 """
print(roll_dice())
""" 摇三颗筛子 """
print(roll_dice(3))
print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
""" 传递参数时可以不按照设定的顺序进行传递 """
print(add(c=20, a=10, b=22))

"""
我们给上面的两个函数的参数都设定了默认值，这也就因为i爱着如果在调用函数的是偶如果没有传入对应参数的值将使用该参数的默认值
所以我们在上面的代码中我们可以使用各种把不同的方式去调用add函数，这跟其他很多编程语言中函数的重载效果是一致的。

其实上面的add函数还有更好的实现方案，因为我们可能会对0个或者多个参数进行加减运算，而具体有多个参数是有调用者来决定
我们作为哈桉树的设计者对这一点是一无所知的，因此在不确定参数的个数的时候我们可以使用可变参数
"""


def add(*args):
    total = 0
    for val in args:
        total += val
    print(total)


print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
print(add(123, 1, 23, 123))

"""
用模块管理函数
对于任何一种编程语言来说，给变量、函数这样的标识符起蜜罐子是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况
最简单的场景就是在同一个.py文件中定义两个同名的函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。
"""


# def foo():
#     print("Hello World")
#
#
# def foo():
#     print("GoodBay World")
#
# foo()


"""
当然上面这种的情况我们很容易就能避免，但是如果项目是有多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为foo的函数
那么怎么解决这个命名冲突的问题呢，答案其实很简单，Python中每个文件就代表了一个模块(module)
我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过过import关键字导入指定的模块就可以区分到底要使用的是那个模块中的foo函数
"""
# 文件头部定义了导入的语句
# foo()


"""
需要说明的时候，如果我们导入的模块除了定义函数之外还有可执行代码，那么Python解释器在导入这个模块的时候就会掉过这些代码
事实上我们可能并不希望如此，英雌我们在模块中编写执行代码，最好是将这些执行代码放入如下所示的条件中
这样的刷除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块名字才是"__main__"
"""

if __name__ == "__main__":
    print("call foo()")
    print('call foo()')
    foo()